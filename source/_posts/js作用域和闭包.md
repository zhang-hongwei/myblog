---
title: 作用域 和 闭包
date: 2021-08-16 22:30:00
tags: js
---

## 什么是作用域

<aside>
💡 **作用域是根据名称查找变量的一套规则**

</aside>

前端作用域是一组规则，用于确定前端代码库中变量的访问方式。就像任何编程语言中的作用域一样，前端作用域规则决定了如何通过名称查找变量。

## 作用域链

遍历嵌套作用域链的规则很简单： 引擎从当前的执行作用域开始查找变量， 如果找不到，就向上一级继续查找。 当抵达最外层的全局作用域时， 无论找到还是没找到， 查找过程都会停止。

这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找

```jsx
function foo() {
  var a = 2;

  function bar() {
    console.log(a);
  }

  return bar;
}

var baz = foo();

baz(); // 2 —— 朋友，这就是闭包的效果。
```

在 foo() 执行后， 其返回值（也就是内部的 bar() 函数） 赋值给变量 baz 并调用 baz()， 实

际上只是通过不同的标识符引用调用了内部的函数 bar()。

bar() 显然可以被正常执行。 但是在这个例子中， 它在自己定义的词法作用域以外的地方

执行。

在 foo() 执行后， 通常会期待 foo() 的整个内部作用域都被销毁， 因为我们知道引擎有垃

圾回收器用来释放不再使用的内存空间。 由于看上去 foo() 的内容不会再被使用， 所以很

自然地会考虑对其进行回收。

而闭包的“神奇” 之处正是可以阻止这件事情的发生。 事实上内部作用域依然存在， 因此

没有被回收。 谁在使用这个内部作用域？ 原来是 bar() 本身在使用。

**闭包指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。**

## 总结

闭包使得函数可以继续访问定义时的词法作用域，无论通过何种手段将内部函数传递到所在的词法作用域以外， 它都会持有对原始定义作用域的引用， 无论在何处执行这个函数都会使用闭包。