---
title: 事件循环
date: 2023-08-24 15:54:25
tags: 事件循环
---

![Untitled](https://s2.loli.net/2023/08/24/RdUGVWJ7Oj8subI.png)

## JavaScript为什么是单线程

---

<aside>
💡 JavaScript 传统上是单线程的。即使有多个内核，也只能在单一线程上运行多个任务，此线程称为主线程（main thread）
单线程就意味JavaScript代码只能从上到下运行，如果有耗时较长的代码就会形成阻塞，页面卡顿，无法操作

网上冲浪越来越流行时，对于开发客户端脚本的需求也逐渐增大。此时，**大部分因特网用户还仅仅通过 28.8 kbit/s 的调制解调器连接到网络**，即便这时网页已经不断地变得更大和更复杂。而更加加剧用户痛苦的是，**仅仅为了简单的表单有效性验证，就要与服务器进行多次地往返交互**。设想一下，用户填完一个表单，点击提交按钮，等待了 30 秒的处理后，看到的却是一条告诉你忘记填写一个必要的字段。

那时正处于技术革新最前沿的 Netscape，开始认真考虑开发一种客户端脚本语言来解决简单的处理问题。

js正是在这种背景下诞生的，而那时候，网页还是如此的简陋，或许他们也没有想到计算机技术发展如此迅速。也或许他们想到了，但是基于浏览器环境下存在很多限制。如果JavaScript是多线程的，那么会涉及到线程之间的通信，而这会增加浏览器的复杂度和资源消耗。因此，JavaScript被设计成单线程的，以避免这些问题。

</aside>

## 为什么会需要事件循环

> 事件循环负责收集用户事件和其他事件，对任务进行排队以便在合适的时候执行回调。然后执行所有处于等待中的JavaScript任务(宏任务)，然后是微任务。然后在开始下一次循环之前执行一些必要的渲染和绘制操作。
因为JavaScript是单线程的。单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。为了协调事件(event)，用户交互(user interaction)，脚本(script)，渲染(rendering)，网络(networking)等，用户代理(user agent)必须使用事件循环
> 

## JavaScript 运行时

在执行 JavaScript 代码的时候，JavaScript 运行时实际上维护了一组用于执行 JavaScript 代码的**代理**。每个代理由一组执行上下文的集合、执行上下文栈、主线程、一组可能创建用于执行 worker 的额外的线程集合、一个任务队列以及一个微任务队列构成。除了主线程（某些浏览器在多个代理之间共享的主线程）之外，其它组成部分对该代理都是唯一的。

### 任务(宏任务) vs 微任务

一个任务就是指计划由标准机制来执行的任何 JavaScript，如程序的初始化、事件触发的回调等。 除了使用事件，你还可以使用 setTimeout或者 setInterval 来添加任务。

任务队列和微任务队列的区别很简单，但却很重要：

- 当执行来自任务队列中的任务时，在每一次新的事件循环开始迭代的时候运行时都会执行队列中的每个任务。在每次迭代开始之后加入到队列中的任务需要**在下一次迭代开始之后才会被执行**.
- 每次当一个任务退出且执行上下文为空的时候，微任务队列中的每一个微任务会依次被执行。不同的是它会等到微任务队列为空才会停止执行——即使中途有微任务加入。换句话说，微任务可以添加新的微任务到队列中，并在下一个任务开始执行之前且当前事件循环结束之前执行完所有的微任务。

## 事件循环

> **宏任务**：script(整体代码)，setTimeout，setInterval，setImmediate，I/O，UI rendering；
> 
> 
>  **微任务**：process.nextTick(Node.js)，Promise，Object.observe，MutationObserver。
> **优先执行宏任务**
> 
1. 所有同步任务都在主线程上执行(默认优先执行script脚本)，形成一个执行栈(execution context stack); 异步任务放在其他地方执行
2. 主线程之外，还存在着“任务队列”。只要异步任务有了运行结果，就会在“任务队列”中放置一个处理该任务的回调函数;
    1. 任务队列又分为两种，宏任务队列（**优先执行宏任务**），微任务队列
3. 一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”，其中对应的异步任务，会结束等待状态，进行执行栈，开始执行;
    1. 取出一个宏任务执行，执行完毕之后，清空所有的微任务
    2. UI渲染更新（ui渲染的时机是在下一个宏任务执行之前执行）
4. 主线程不断重复第三步。

## 为什么Promise的then优先于setTimeout先执行

<aside>
💡 **promise.then是微任务，setTimeout的回调是宏任务。本次事件循环产生的微任务会在本次的宏任务执行完毕之后立即执行；而本次产生的宏任务会在下一次事件循环中继续执行**

</aside>

## 以上概括

调用站中的同步任务都执行完毕，站内被清空了，就代表主线程空闲了，这个时候就会去任务队列中按照顺序读取一个任务放入到栈中执行。每次栈内被清空，都会读取任务队列有没有任务，有就读取执行，一直循环 *读取-执行* 的操作。
