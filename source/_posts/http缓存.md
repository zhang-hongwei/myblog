---
title: http缓存
date: 2020-05-10 22:10:00
tags: http
---

<aside>
**强缓存：**不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的network选项中可以看到该请求返回200的状态码; 

**协商缓存：**向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源； 

**两者的共同点是：**都是从客户端缓存中读取资源；
**区别：**是强缓存不会发请求，协商缓存会发请求。

</aside>
![](https://s2.loli.net/2023/08/28/2tRMqSG53JfhE9D.png)

**结论：**

**强缓存**：根据Expires（response header里的过期时间）判断，浏览器再次加载资源时，如果在这个过期时间内，则命中强缓存，并不会向服务端发起请求，展示为200状态。

**协商缓存**：客户端向服务端发送带有If-None-Match和If-Modified-Since的请求进行协商判断，如果资源没有变化继续使用本地缓存，记录为304状态；如果资源发生变化，服务端响应数据，记录为200状态。

仅仅是已缓存文档过期了并不意味着它和原始服务器上目前处于活跃状态的文档有实际的区别；这只是意味着到了要进行核对的时间了。这种情况被称为“服务器再验证”，说明缓存需要询问原始服务器文档是否发生了变化。
• 如果再验证显示内容发生了变化，缓存会获取一份新的文档副本，并将其存储在旧文档的位置上，然后将文档发送给客户端。
• 如果再验证显示内容没有发生变化，缓存只需要获取新的首部，包括一个新的过期日期，并对缓存中的首部进行更新就行了。

### **什么是浏览器缓存**

浏览器缓存(Brower Caching)是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。

### 浏览器缓存的优点有

1.减少了冗余的数据传输，节省了网费

2.减少了服务器的负担，大大提升了网站的性能

3.加快了客户端加载网页的速度

浏览器缓存主要有两类：缓存协商和彻底缓存，也有称之为协商缓存和强缓存。

1.强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的network选项中可以看到该请求返回200的状态码;

2.协商缓存：向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；

两者的共同点是，都是从客户端缓存中读取资源；区别是强缓存不会发请求，协商缓存会发请求。

## **强制缓存**

### Expires：

response header里的过期时间，浏览器再次加载资源时，如果在这个过期时间内，则命中强缓存。

- 服务端和浏览器的时间可能不同, 导致缓存过期时间出现偏差
- 客户端可以通过修改系统时间来继续使用缓存或提前使缓存失效

### Cache-Control：

<aside>
💡 优先级高于Expires，如果在`Cache-Control`响应头设置了 "max-age" 或者 "s-max-age" 指令，那么 `Expires` 头会被忽略。

</aside>

当值设为max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。

cache-control除了该字段外，还有下面几个比较常用的设置值：

- no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。
- no-store：直接禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。
- public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。
- private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。

Expires:设置以分钟为单位的绝对过期时间, 设置相对过期时间, max-age指明以秒为单位的缓存时间,

Expires优先级比Cache-Control低, 同时设置Expires和Cache-Control则后者生效.

## **协商缓存**
### Last-Modify/If-Modify-Since：
浏览器第一次请求一个资源的时候，服务器返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间；当浏览器再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存

### Etag/If-None-Match：
web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。If-None-Match：发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定是否命中协商缓存；

ETag和Last-Modified的作用和用法，他们的区别：
- 1.Etag要优于Last-Modified。Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；
- 2.在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值；
- 3.在优先级上，服务器校验优先考虑Etag。

## 浏览器缓存过程

1.浏览器第一次加载资源，服务器返回200，浏览器将资源文件从服务器上请求下载下来，并把response header及该请求的返回时间一并缓存；

2.下一次加载资源时，先比较当前时间和上一次返回200时的时间差，如果没有超过cache-control设置的max-age，则没有过期，命中强缓存，不发请求直接从本地缓存读取该文件（如果浏览器不支持HTTP1.1，则用expires判断是否过期）；如果时间过期，则向服务器发送header带有If-None-Match和If-Modified-Since的请求

3.服务器收到请求后，优先根据Etag的值判断被请求的文件有没有做修改，Etag值一致则没有修改，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回200；；

4.如果服务器收到的请求没有Etag值，则将If-Modified-Since和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回304；不一致则返回新的last-modified和文件并返回200；

### **缓存存储位置：**

内存缓存(memory cache)和硬盘缓存(disk cache)

| 区别 | 内存缓存 | 硬盘缓存 |
| --- | --- | --- |
| 存储内容 | JS，字体，图片等 | CSS等 |
| 读取速度 | 快 | 慢 |
| 时效性 | 进程关闭则清空 | 可以缓存较长时间 |
| 空间 | 空间小 | 空间大 |

## 缓存在前端应用

单页面应用中，

- 入口文件index.html设置为协商缓存，每次都向服务器发起请求，确定资源是否过期。
- 其他的资源，css，js这些都会设置成强缓存。因为这些文件名在打包之后会带上hash值，如果修改了内容，那么打包之后因为hash值变化，所以文件名也是会变化的。这些文件在index.html里引入

## 为什么有了**If-Modified-Since(Last-Modified) 还需要 If-None-Match(Etag)**

1. 有些文档可能会被周期性地重写（比如，从一个后台进程中写入），但实际包含
的数据常常是一样的。尽管内容没有变化，但修改日期会发生变化。
2.  有些文档可能被修改了，但所做修改并不重要，不需要让世界范围内的缓存都重
装数据（比如对拼写或注释的修改）。
3.  有些服务器无法准确地判定其页面的最后修改日期。
4.  有些服务器提供的文档会在亚秒间隙发生变化（比如，实时监视器），对这些服
务器来说，以一秒为粒度的修改日期可能就不够用了。